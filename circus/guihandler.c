/*
 * guihandler.c - handles gui events from the serverconnection gui part
 * Copyright (C) 1998 Ivo van der Wijk (ivo@cs.vu.nl) and others
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
#include "guihandler.h"
#include "internalevent.h"

#include "const.h"

extern int dbg;

/*
 * eventhandling
 *
 * The next methods handle events generated by the connection-specific
 * part of the gui
 */



#define pack(f) new func_packer(this, &guihandler::f)

guihandler::guihandler(): cmdhandler()
{
	dispatch_table["input_typed"] = pack(handleinput);
	dispatch_table["target_changed"] = pack(targetchange);
	dispatch_table["nick_changed"] = pack(nickchange);
	dispatch_table["w_mode_changed"] = pack(wmodechange);
	dispatch_table["i_mode_changed"] = pack(imodechange);
	dispatch_table["r_mode_changed"] = pack(rmodechange);
	dispatch_table["targetlist_changed"] = pack(targetlistchange);
	dispatch_table["target_menu"] = pack(open_target_menu);

	
	/*
	 * Menu Events
	 *
	 * This needs improvements - hush generates lousy messages but
	 * plush is much better (I think)
	 */

	dispatch_table["Leave/Close"] = pack(handle_menu_gen_op);
	dispatch_table["Who/Whois"] = pack(handle_menu_gen_op);
	dispatch_table["Bans"] = pack(handle_menu_ch_op);
	dispatch_table["Invite-only"] = pack(handle_menu_ch_op);
	dispatch_table["Key"] = pack(handle_menu_ch_op);
	dispatch_table["Limit"] = pack(handle_menu_ch_op);
	dispatch_table["Moderated"] = pack(handle_menu_ch_op);
	dispatch_table["No-messages"] = pack(handle_menu_ch_op);
	dispatch_table["Private"] = pack(handle_menu_ch_op);
	dispatch_table["Secret"] = pack(handle_menu_ch_op);
	dispatch_table["Topic"] = pack(handle_menu_ch_op);
	dispatch_table["Version"] = pack(handle_menu_ctcp_op);
	dispatch_table["Clientinfo"] = pack(handle_menu_ctcp_op);
	dispatch_table["Userinfo"] = pack(handle_menu_ctcp_op);
	dispatch_table["Finger"] = pack(handle_menu_ctcp_op);
	dispatch_table["Time"] = pack(handle_menu_ctcp_op);
	dispatch_table["Ping"] = pack(handle_menu_ctcp_op);
}

guihandler::~guihandler()
{
}

int	guihandler::handleinput(int, char **argv)
{
	cstring	msgs = getinput();
	cstring_iter	msg_list = msgs;
	cstring	msg;

	if(msgs.length() == 0)
		return false;

	while((int)(msg = msg_list('\n')))
	{
		if(msg[0] == '/')
		{
			// pass to cmdline handler. Make sure "" is passwd
			// as current of no real current 
			tk << CMDLINE << sessionid << " \"" << escape(current)
			   << "\" \"" << escape(msg(1)) << "\"" << end;
		}
		else if(current == "")
			insert("No current channel or query\n");
		else
		{
			tk << CMDLINE << sessionid << " \"" << escape(current)
			   << "\" \"msg " << escape(current) << " "
			   << escape(msg) << "\"" << end;
		}
		delinput();
	}
	return true;
}

int	guihandler::nickchange(int, char **)
{
	cstring	newnick = getnick();

	if(!isnick(newnick))
	{
		insert(newnick + " is not a valid nickname\n");
		setnick(nick);
	}
	else if(ircserver::state(ircserver::connected))
		ircserver::nick(newnick);
	else
		setnick(newnick);
	refocus();			// set focus to inputentry
	return true;
}

int	guihandler::targetchange(int, char **)
{
	cstring	which = gettarget();

	if(which.length() == 0)		// ignore empty input
	{
		set_current(current);
		return false;
	}

	if(ischannel(which))
		targets::addchannel(which);
	else if(isnick(which))
		targets::addquery(which);
	else
	{
		insert(which + " is not a valid nick or channel\n");
		set_current(current);
		return false;
	}

	refocus();			// set focus to inputentry
	return true;
}

int	guihandler::handle_modech(int /*argc*/, char ** /*argv*/, int mode)
{
	cstring cmd;

        if(get_mode() & mode)
                cmd = "-";
        else
                cmd = "+";
 
        switch(mode)
        {
	case MODE_WALLOP:
		cmd += "w";
		break;
	case MODE_INVISIBLE:
		cmd += "i";
		break;
	case MODE_SERV_NOT:		// obsolete!
		cmd += "s";
		break;
	case MODE_RESTRICTED:
		cmd += "r";
		break;
	}
	ircserver::mode(nick, cmd);
	mode_toggle(mode);
	mode_disable(mode);
	return true;
}

int	guihandler::wmodechange(int argc, char ** argv)
{
	return handle_modech(argc, argv, MODE_WALLOP);
}

int	guihandler::imodechange(int argc, char ** argv)
{
	return handle_modech(argc, argv, MODE_INVISIBLE);
}

int	guihandler::rmodechange(int argc, char ** argv)
{
	return handle_modech(argc, argv, MODE_RESTRICTED);
}


int	guihandler::targetlistchange(int, char **/* argv */)
{
	cstring	which = gettargetlist();

	if(which == "")		// double click in empty listbox
		return true;
	if(ischannel(which))
		targets::addchannel(which);
	else
		targets::addquery(which);
	return true;
}

int	guihandler::open_target_menu(int, char **)
{
	int	size = targetslist->size();
	int	cnt = 0;
	int	ch = false;
	int	ppl = false;

	for(int i = 0; i < size; i++)
		if(targetslist->selected(i))
		{
			cstring	which = targetslist->get(i);

			if(ischannel(which))
				ch = true;
			else
				ppl = true;
			cnt++;
		}

	if(cnt == 0)
		return false;
#warning "menu code removed"
//	else
//		popup_menu(_event->x_root(), _event->y_root(), ch, ppl);
	return true;
}

int	guihandler::handle_menu_ch_op(int argc, char **argv)
{
	cstring	command = argv[1];
	int	size = targetslist->size();
	cstring	sign = "+";
	cstring	params;

	if(argc == 4)
	{
		cstring	menu = argv[2];
		if(menu == "DelModeMenu")
			sign = "-";
	}

	for(int i = 0; i < size; i++)
	{
		if(targetslist->selected(i))
		{
			cstring	which = targetslist->get(i);
			if(ischannel(which))
			{
				if(command == "Bans")
					params = "b";
				else if(command == "Invite-only")
					params = "i";
				else if(command == "Key")
				{
					params = "k ";
#warning "Niet zo abstract, ditte"
					params += 
					     ((channel_target *)targetlist[which])->get_key();
				}
				else if(command == "Limit")
					params = "l";
				else if(command == "Moderated")
					params = "m";
				else if(command == "No-messages")
					params = "n";
				else if(command == "Private")
					params = "p";
				else if(command == "Secret")
					params = "s";
				else if(command == "Topic")
					params = "t";
				ircserver::mode(which, sign + params);	
			}
			else
				return true;
		}
	}
	return true;
}

int	guihandler::handle_menu_ctcp_op(int, char **argv)
{

	cstring	command = argv[1];
	int	size = targetslist->size();

	for(int i = 0; i < size; i++)
	{
		if(targetslist->selected(i))
		{
			cstring	which = targetslist->get(i);
			cstring msg = "";
			if(command.compare("ping"))
				msg << time(NULL);
			ircserver::ctcp(which, command.upper(), msg);
		}
	}
	return true;
}

void	guihandler::handle_invite(const cstring &channel)
{
	int	size = targetslist->size();

	for(int i = 0; i < size; i++)
	{
		if(targetslist->selected(i))
		{
			cstring	which = targetslist->get(i);
			if(!ischannel(which))
				ircserver::invite(which, channel);
		}
	}
}

int	guihandler::handle_menu_gen_op(int, char **argv)
{
#warning "guihandler::handle_menu_gen_op not implemented"

}

int	guihandler::operator()()
{
	int	argc = _event->argc();
	int	i;
	char	**argv = _event->argv();
	cstring	eventtype = argv[0];
	cstring	cmd;
	
	if(dbg > 5)
	{
           cout << "GUIHANDLER: An event happened:" << eventtype << endl;
	   for(i = 0; i < argc; i++)
		cout << "arg: " << i << ": " << argv[i] << endl;
	}
	cstring  command = _event->arg(1);

	func_packer  *d = (func_packer *)dispatch_table[command];
 
	if(d)
		d->execute(_event->argc(), _event->argv());
	else if(ischannel(command))	// if it's a channelname, it's an invite
		handle_invite(command);
	else // pass event to cmdhandler
		return cmdhandler::operator()();
	return true;
}
